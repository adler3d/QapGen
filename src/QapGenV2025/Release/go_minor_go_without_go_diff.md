<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# "4. Табличка различий (ещё раз, кратко)" - а можешь добавить в неё ещё go_minor. вот его код на случай если ты его забыл:template<class TYPE_TEMP,class TYPE>

bool i_dev::go_minor(TYPE\&ref)
{
//Adler: lex_a=read<TYPE_TEMP>(); if(lex_a.ok){return false;}else{lex_b=read<TYPE>();return lex_b.ok;}
TYPE_TEMP temp;
t_fallback scope(*this,__FUNCTION__);
auto\&ok=scope.ok;
if(isLoad())
{
{
t_fallback tmp(*this,__FUNCTION__,"::load");
tmp.ok=go_for_item(*this,temp);
if(tmp.ok){
tmp.ok=false;ok=false;
tmp.pos=scope.pos;
}
}
//scope.log_clear();
if(!ok)return ok;
}
if(isSave())
{
//auto\&Env=getEnv();
string tmp_mem;
{
t_save_dev dev(/*Env,*/tmp_mem);
bool ok=go_for_item(dev,ref);
QapAssert(ok);
}
{
t_load_dev dev(/*Env,*/tmp_mem);
bool ok=dev.go_auto(temp);
QapAssert(!ok);
TYPE obj;
ok=dev.go_auto(obj);
QapAssert(ok);
}
}
ok=go_for_item(*this,ref);
return ok;
}

Конечно! Добавлю в таблицу различий метод `go_minor` с учётом предоставленного кода и его логики.

---

## Таблица сравнения методов `go_diff`, `go_without` и `go_minor`

| Критерий | `go_diff` | `go_without` (`go_exclude`) | `go_minor` |
| :-- | :-- | :-- | :-- |
| **Основная задача** | Проверить, что парсимый объект отличается по размеру (позиции) от объекта другого типа | Парсить строку/ноду, исключая вхождения определённого типа | Попытаться распарсить объект `TYPE_TEMP`; если удалось — вернуть `false`, иначе парсить `TYPE` |
| **Что проверяет** | Отличие по размеру (позиции в потоке) | Отсутствие запрещённых элементов в строке или структуре | Наличие исключаемого варианта `TYPE_TEMP`; если есть — отказ, иначе парсинг `TYPE` |
| **Тип параметра** | Любой тип объекта | Обычно строка (`std::string`) или похожий тип | Два типа — `TYPE_TEMP` (исключаемый), `TYPE` (основной) |
| **Поведение при загрузке** | Парсит объект `ref`, если не совпадает с `TYPE_TEMP` | Парсит строку/ноду, прерывается при встрече `TYPE` | Сначала пытается распарсить `TYPE_TEMP`, если успешно — возвращает `false`; иначе парсит `TYPE` |
| **Поведение при сохранении** | Просто сохраняет объект `ref` | Сохраняет строку/ноду без изменений | Сохраняет объект `ref`, при этом проверяет, что `TYPE_TEMP` не сериализуется |
| **Пример использования** | Исключить ключевые слова при парсинге идентификатора (см. выше) | Исключить определённые символы или конструкции из строки или блока | Альтернативный парсер с исключением определённого варианта |
| **Когда использовать** | Исключить конкретный тип с учётом позиции и размера | Исключить подстроки или символы внутри загружаемой ноды | Когда нужно попытаться пропустить вариант `TYPE_TEMP` и перейти к парсингу `TYPE` |


---

## Краткое пояснение `go_minor`

- Метод полезен для реализации альтернативных правил, где один вариант парсинга исключает другой.
- Если при загрузке успешно распарсили `TYPE_TEMP`, метод возвращает `false` — значит, основной вариант `TYPE` не применяется.
- Если `TYPE_TEMP` не распарсился, пробуем `TYPE`.
- При сохранении метод сохраняет только `TYPE`, проверяя, что `TYPE_TEMP` не сериализуется.

---

Если хочешь, могу помочь с примерами использования `go_minor` и доработать документацию по нему!

